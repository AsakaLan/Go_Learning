## 一、如何优化Mysql

### sql语句的优化

1. 尽力避免使用子查询
2. 用In 来代替or
3. 禁止不必要的order by排序
4. 只返回必要的列，用具体的字段列表来代替select * 语句

### 索引的优化

1. 最佳左前缀法则
2. 尽量使用覆盖索引
3. 在组合/联合索引中，将有区分度的索引放在前面
4. 使用前缀索引

### 表结构的优化

1. 使得数据表的结构符合三大范式

### 分库分表

**分库分表怎么设计**

分库分表方案、分库分表中间件、可能遇到的问题。

### 分库分表方案

* 水平分库：以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。
* 水平分表：以字段为依据，按照一定策略，将一个表中的数据拆分到多个表中。
* 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
* 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

### 常用分库分表中间件

* sharding-jdbc（当当）
* Mycat
* TDDL（淘宝）
* Oceanus(58同城数据库中间件)
* vitess（谷歌开发的数据库中间件）
* Atlas(Qihoo 360)

### 分库分表可能遇到的问题

* 事务问题：需要用到分布式事务。
* 数据迁移、容量规划、扩容。
* 跨节点Join的问题：可以通过分两次查询实现。
* 跨节点的count、order by、group by以及聚合函数问题：分别在各个节点上将得到的结果在应用程序端进行合并。

## 二、InnoDB与MyISAM的区别

* InnoDB支持事务，MyISAM不支持事务。
* InnoDB支持外键，MyISAM不支持外键。
* InnoDB支持MVCC,MyISAM不支持。
* InnoDB支持表、行级锁，MyISAM只支持表锁。
* InnoDB必须有主键，MyISAM可以没有主键。
* nnodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小。
* Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。

## 三、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

可以从多个维度去看这个问题：

1. 查询是否够快？是否稳定？
2. 存储数据多少，查找磁盘次数。
3. 为什么不是二叉树？为什么不是二叉平衡树？为什么不是B树，为什么不是红黑树 ，而偏偏是B+树。

**为什么不是一般二叉树？**

如果使用二叉树，在最坏的情况下会退化为链表形态，变成了[顺序查找](https://so.csdn.net/so/search?q=顺序查找&spm=1001.2101.3001.7020)，遍历整个链。
当数据量大的情况下，层数会不受控的增多，导致效率低下。![在这里插入图片描述](https://img-blog.csdnimg.cn/d59ad88c6ca8481aaed422bc1554b1f2.png)

**为什么不是平衡二叉树**？

平衡二叉树可是每个节点只存储一个键值和数据的，会导致树的深度越来越深，意味着读取磁盘的次数越多，严重影响效率。

**为什么不是红黑树**

红黑树但是一种特殊的[平衡二叉树](https://so.csdn.net/so/search?q=平衡二叉树&spm=1001.2101.3001.7020)，他不会出现二叉树中的最坏情节，他会进行平衡。
但是也有一个问题，就是由于他还是属于二叉树，一个父节点只能跟着2个子节点。如果存在几千万数据，那么红黑树会非常的深同样需要大量io操作，这样一句无法快速的查找到我们想要的数据了。

![在这里插入图片描述](https://img-blog.csdnimg.cn/eb580ac93fbb470eb3968a651f32d6c0.png)

**为什么不是B树而是B+树**？

1. B树不仅存键值，也存数据；B+树非叶子节点是不存数据的，仅存储键值，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
2. B+树索引的所有数据均存储在叶子节点，而且数据是按顺序排列的，通过双向链表相连，从而使得范围查找，排序查找，等等变得更加有效、快捷。

## 四、索引

**聚簇索引和非聚簇索引**

在InnoDB，索引B+树的叶子节点存储了整行数据的是主键索引，也被称为聚簇索引，即将数据存储和索引放在了一起，找到了索引就找到了数据。

而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。

聚簇索引和非聚簇索引的区别：

1. 非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键。
2. 对于InnoDB来说，想要查找数据还需要根据主键再去聚簇索引里进行查找，这个过程称为回表。
3. 通常情况，聚簇索引只会查一次，而非聚簇索引会查多次。
4. 聚簇索引中键值的逻辑顺序决定了表中相应行的物理顺序。
5. 非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

**非聚簇索引一定会回表查询吗？**

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

**联合索引是什么？为什么需要主要联合索引中的顺序？**

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

**Mysql的最左前缀原则？**

最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。

**前缀索引**

因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。

**怎么查看mysql语句中有没有用到索引？**

explain

**为什么官方建议使用自增长主键作为索引？？**

结合B+Tree的特点，自增主键是连续的，可以在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

**如何创建索引？**

1.  在执行CREATE TABLE时创建索引。
2. 使用ALTER TABLE命令去增加索引。
3. 使用CREATE INDEX命令创建。

**创建索引时需要注意什么？**

可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则。

**索引那些情况会失效**

* 查询条件包含or，可能导致索引失效
* 如何字段类型是字符串，where时一定用引号括起来，否则索引失效
* like通配符可能导致索引失效。
* 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。

**索引不适合哪些场景？**

* 数据量少的情况
* 更新比较频繁的也不适合加索引
* 区分度低的字段不适合加索引

**建索引的原则有哪些？**

1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
3. 尽量选择区分度高的列作为索引。
4. 索引列不能参与计算。
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

**索引的一些潜规则**

* 覆盖索引.
* 回表.
* 索引数据结构(b+树)
* 最左前缀原则.
* 索引下推.

**索引的种类**

1. 从存储结构上分为 btree索引、hash索引、full-index索引
2. 从应用层来分：普通、唯一、符合
3. 根据数据的物理存储与键值的逻辑(索引) 聚簇索引、非聚簇索引

## 五、MySQL主从复制

**为什么需要主从复制**

随着业务的增长，一台数据服务器已经满足不了需求了，负载过重。这个时候就需要减压了，实现负载均衡读写分离，一主一丛或一主多从。

主服务器只负责写，而从服务器只负责读，从而提高了效率减轻压力。

主从复制可以分为：

- 主从同步：当用户写数据主服务器必须和从服务器同步了才告诉用户写入成功，等待时间比较长。
- 主从异步：只要用户访问写数据主服务器，立即返回给用户。
- 主从半同步：当用户访问写数据主服务器写入并同步其中一个从服务器就返回给用户成功。

**形式**

一主一从、一主多从、多主一从、双主复制

**原理**

MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。

**工作过程**

MySQL 的主从复制工作过程大致如下：

1. 从库生成两个线程，一个 I/O 线程，一个 SQL 线程;
2. I/O 线程去请求主库的 binlog，并将得到的 binlog 日志写到 relay log(中继日志) 文件中;
3. 主库会生成一个 log dump 线程，用来给从库 I/O 线程传 binlog;
4. SQL 线程会读取 relay log 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致;

![img](https://dl-harmonyos.51cto.com/images/202204/5132b2c63a1331515f505679557dcf5971e8bc.png)



![MySQL 主从复制过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



## MySQL优化了解吗？说一下从哪些方面可以做到性能优化？

* 为搜索字段创建索引
* 避免使用select*,列出需要查询的字段
* 分表
* 选择正确的存储引擎

## 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？

单个数据库实例能够承载的并发访问量和数据量是有限的，当系统的并发访问量或者数据量超过这个限制时，就需要考虑使用分库分表来优化系统的架构设计，使其能够承载更大的并发量和数据量，并给用户提供良好的使用体验。当然，分库和分表其实是两个事情，两者并不是都会同时出现。

### 1. 分库解决了什么问题

分库主要解决的是**并发量大**的问题，因为单个数据库实例能够提供的连接数是有限的，当系统并发量不断增加，我们势必需要增加更多的微服务实例来承载更多的业务请求，而每个微服务实例都会占用一定量的数据库连接，因此，当数据库连接数不够用了，就只能通过增加数据库实例的方式来提供更多的数据库连接，进而提升系统整体的并发度。

### 2. 分表解决了什么问题

分表主要解决的是**数据量大**的问题，因为单表的数据量很大时，即使并发访问量不大，但单表的存储和查询的性能已经遭遇了瓶颈，通过索引优化等手段虽然能够一定程度上提升效率，但当单表数据量超过 500 万行或者单表存储容量超过 2GB（经验值，实际要看业务的具体情况） 之后，分表就应该提上日程了。一般都是将数据拆分到多张表中，来减少单表的数据量，从而提升查询的速度

## 主键索引和唯一索引的区别？

* 普通索引:无任何约束作用，就是用来提高查询效率
* 唯一索引:在普通索引的基础上，增加了唯一性约束，要求索引列的值唯一，但可以为空，一张表可以存在多个唯一索引。
* 主键索引: 在唯一索引的基础上又增加了不能为空的约束，而且一张表最多只能有一个主键索引，但一个主键索引可以包含多个字段。
* 全文索引:不经常用的

## Mysql如何实现acid？

### 何为事务？

**一系列操作组成，要么全部成功，要么全部失败。它具备ACID四大特性，在并发下，可能存在脏读、幻读、不可重复读的并发问题，于是又引出了四大隔离级别**

事务具有ACID四个特性，那么事务是如何保证这4个特性的呢？

1. 原子性(A) 一系列操作要么全部成功，要么全部失败。
2. 隔离性(I) 事务的结果只有提交了其他事务才可见
3. 一致性(C) 数据库总是从一个一致状态变到另一个一致状态
4. 持久性(D) 提交事务后，对数据的修改是永久的。

**如何保证原子性**

主要依靠回滚日志(undo)，既可以用来实现MVCC，也可以用来保证原子性，实现原子性的关键，就在于事务执行undo操作可以撤销所有成功执行的sql语句

undo log作用：undolog记录事务开始前老版本数据，用于实现回滚，保证原子性，实现MVCC，会将数据修改前的旧版本保存在undolog，然后行记录有个隐藏字段回滚指针指向老版本。

**如何保证持久性**

redo log 是一种物理日志，我们再更新数据库时，先将更新操作记录在redo log日志，等redo log满了或则MYSQL空闲了再刷盘。其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先装小推车，等不忙的时候再装库。

**如何保证隔离性**

说到隔离性，我们都知道MYSQL有四种隔离级别，用来解决存在的并发问题。脏读、幻读、不可重复读。那么不同隔离级别，隔离性是怎样实现的呢？具体实现原理是怎样的呢？

一句话：**锁+mvcc**

总之，MYSQL的隔离性便是由MVCC+锁来保证，各个隔离级别实现原理我做了一下归纳总结：

隔离级别原理及解决问题分析：

1. 读未提交：原理：直接读取数据，不能解决任何并发问题
2. 读已提交：读操作不加锁，写操作加排他锁，解决了脏读。原理：利用MVCC实现，每一句语句执行前都会生成Read View（一致性视图）
3. 可重复读：MVCC实现，只有事务开始时会创建Read View，之后事务里的其他查询都用这个Read View。解决了脏读、不可重复读，快照读（普通查询，读取历史数据）使用MVCC解决了幻读，当前读（读取最新提交数据）通过间隙锁解决幻读（lock in share mode、for update、update、detete、insert），间隙锁在可重复读下才生效。（**默认隔离级别**）
4. 可串行化：原理：使用锁，读加共享锁，写加排他锁，串行执行

总结：读已提交和可重复读实现原理就是MVCC Read View不同的生成时机。可重复读只在事务开始时生成一个Read View，之后都用的这个；读已提交每次执行前都会生成Read View

**索引**

**如何创建索引？**

alter table

create index

**如何设计索引？**

一句话看性价比，总的来说就是创建索引的目的就是在尽可能占用少量内存的情况下去涉及一个合适的索引使得查询速度更快。

1. 一般建在 `where` 字段匹配条件后，为了让创建索引所带来的好处大于其坏处，我们一定要在数据量大，也就是**基数大**的情况下才考虑索引。”
2. 为了使得效率更高，应该选择**区分度大**，**匹配度高**的字段建立索引 。而且索引**不适合于频繁更新**的数据，因为操作数据同事需要维护索引又得花费时间。”
3. 觉得我们创建索引方面，我们应该尽量扩展索引，而不是创建新的索引，可以合理利用联合索引，如(a)->(a,b) 。”

**索引失效**

不恰当的使用索引，不仅没有提高性能，反而占额外内存空间，影响效率

1. 比如，我们在写模糊查询时，如果以 `%`开头，索引会因此失效，为什么？
   1. 我们通常用的索引数据结构是`B+树`，而索引是**有序排列**的；索引的排列顺序是根据比较字符串的首字母排序的，如果首字母相同，就根据比较第二个字母进行排序，以此类推
   2. 因此如果把 `%` 放在了前面，最左的 n 个字母便是模糊不定的，无法根据索引的`有序性` 准确的定位到某一个索引，只能进行**全表扫描**，找出符合条件的数据

**如何优化索引？从那些角度出发？**

索引+sql语句+数据库结构优化+优化器优化+架构优化

**索引为啥不用hash实现**

hash 底层是哈希表实现，等值查询，可以快速定位，一般情况效率很高，不稳定，无法用于排序分组，无法模糊查询

**覆盖索引** 就是索引字段覆盖了查询语句涉及的字段，直接通过索引文件就可以返回查询所需的数据，不必通过回表操作。”

**回表** 通过索引去找到主键，再根据主键 ID 去主键索引查，`InnoDB` 使用聚簇索引，它的二级索引就是这样一个模式





























