## 一、如何优化Mysql

### sql语句的优化

1. 尽力避免使用子查询
2. 用In 来代替or
3. 禁止不必要的order by排序
4. 只返回必要的列，用具体的字段列表来代替select * 语句

### 索引的优化

1. 最佳左前缀法则
2. 尽量使用覆盖索引
3. 在组合/联合索引中，将有区分度的索引放在前面
4. 使用前缀索引

### 表结构的优化

1. 使得数据表的结构符合三大范式

### 分库分表

**分库分表怎么设计**

分库分表方案、分库分表中间件、可能遇到的问题。

### 分库分表方案

* 水平分库：以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。
* 水平分表：以字段为依据，按照一定策略，将一个表中的数据拆分到多个表中。
* 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
* 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

### 常用分库分表中间件

* sharding-jdbc（当当）
* Mycat
* TDDL（淘宝）
* Oceanus(58同城数据库中间件)
* vitess（谷歌开发的数据库中间件）
* Atlas(Qihoo 360)

### 分库分表可能遇到的问题

* 事务问题：需要用到分布式事务。
* 数据迁移、容量规划、扩容。
* 跨节点Join的问题：可以通过分两次查询实现。
* 跨节点的count、order by、group by以及聚合函数问题：分别在各个节点上将得到的结果在应用程序端进行合并。

## 二、InnoDB与MyISAM的区别

* InnoDB支持事务，MyISAM不支持事务。
* InnoDB支持外键，MyISAM不支持外键。
* InnoDB支持MVCC,MyISAM不支持。
* InnoDB支持表、行级锁，MyISAM只支持表锁。
* InnoDB必须有主键，MyISAM可以没有主键。
* nnodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小。
* Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。

## 三、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

可以从多个维度去看这个问题：

1. 查询是否够快？是否稳定？
2. 存储数据多少，查找磁盘次数。
3. 为什么不是二叉树？为什么不是二叉平衡树？为什么不是B树，为什么不是红黑树 ，而偏偏是B+树。

**为什么不是一般二叉树？**

如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

**为什么不是平衡二叉树**？

平衡二叉树可是每个节点只存储一个键值和数据的，会导致树的深度越来越深，意味着读取磁盘的次数越多，严重影响效率。

**为什么不是B树而是B+树**？

1. B树不仅存键值，也存数据；B+树非叶子节点是不存数据的，仅存储键值，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
2. B+树索引的所有数据均存储在叶子节点，而且数据是按顺序排列的，通过双向链表相连，从而使得范围查找，排序查找，等等变得更加有效、快捷。

## 四、索引

**聚簇索引和非聚簇索引**

在InnoDB，索引B+树的叶子节点存储了整行数据的是主键索引，也被称为聚簇索引，即将数据存储和索引放在了一起，找到了索引就找到了数据。

而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。

聚簇索引和非聚簇索引的区别：

1. 非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键。
2. 对于InnoDB来说，想要查找数据还需要根据主键再去聚簇索引里进行查找，这个过程称为回表。
3. 通常情况，聚簇索引只会查一次，而非聚簇索引会查多次。
4. 聚簇索引中键值的逻辑顺序决定了表中相应行的物理顺序。
5. 非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

**非聚簇索引一定会回表查询吗？**

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

**联合索引是什么？为什么需要主要联合索引中的顺序？**

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

**Mysql的最左前缀原则？**

最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。

**前缀索引**

因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。

**怎么查看mysql语句中有没有用到索引？**

explain

**为什么官方建议使用自增长主键作为索引？？**

结合B+Tree的特点，自增主键是连续的，可以在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

**如何创建索引？**

1.  在执行CREATE TABLE时创建索引。
2. 使用ALTER TABLE命令去增加索引。
3. 使用CREATE INDEX命令创建。

**创建索引时需要注意什么？**

可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则。

**索引那些情况会失效**

* 查询条件包含or，可能导致索引失效
* 如何字段类型是字符串，where时一定用引号括起来，否则索引失效
* like通配符可能导致索引失效。
* 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。

**索引不适合哪些场景？**

* 数据量少的情况
* 更新比较频繁的也不适合加索引
* 区分度低的字段不适合加索引

**建索引的原则有哪些？**

1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
3. 尽量选择区分度高的列作为索引。
4. 索引列不能参与计算。
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

**索引的一些潜规则**

* 覆盖索引
* 回表
* 索引数据结构(b+树)
* 最左前缀原则
* 索引下推

























