## 一、如何优化Mysql

### sql语句的优化

1. 尽力避免使用子查询
2. 用In 来代替or
3. 禁止不必要的order by排序
4. 只返回必要的列，用具体的字段列表来代替select * 语句

### 索引的优化

1. 最佳左前缀法则
2. 尽量使用覆盖索引
3. 在组合/联合索引中，将有区分度的索引放在前面
4. 使用前缀索引

### 表结构的优化

1. 使得数据表的结构符合三大范式

### 分库分表

**分库分表怎么设计**

分库分表方案、分库分表中间件、可能遇到的问题。

### 分库分表方案

* 水平分库：以字段为依据，按照一定策略，将一个库中的数据拆分到多个库中。
* 水平分表：以字段为依据，按照一定策略，将一个表中的数据拆分到多个表中。
* 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
* 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

### 常用分库分表中间件

* sharding-jdbc（当当）
* Mycat
* TDDL（淘宝）
* Oceanus(58同城数据库中间件)
* vitess（谷歌开发的数据库中间件）
* Atlas(Qihoo 360)

### 分库分表可能遇到的问题

* 事务问题：需要用到分布式事务。
* 数据迁移、容量规划、扩容。
* 跨节点Join的问题：可以通过分两次查询实现。
* 跨节点的count、order by、group by以及聚合函数问题：分别在各个节点上将得到的结果在应用程序端进行合并。

## 二、InnoDB与MyISAM的区别

* InnoDB支持事务，MyISAM不支持事务。
* InnoDB支持外键，MyISAM不支持外键。
* InnoDB支持MVCC,MyISAM不支持。
* InnoDB支持表、行级锁，MyISAM只支持表锁。
* InnoDB必须有主键，MyISAM可以没有主键。
* nnodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小。
* Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。

## 三、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

可以从多个维度去看这个问题：

1. 查询是否够快？是否稳定？
2. 存储数据多少，查找磁盘次数。
3. 为什么不是二叉树？为什么不是二叉平衡树？为什么不是B树，为什么不是红黑树 ，而偏偏是B+树。

**为什么不是一般二叉树？**

如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

**为什么不是平衡二叉树**？

平衡二叉树可是每个节点只存储一个键值和数据的，会导致树的深度越来越深，意味着读取磁盘的次数越多，严重影响效率。

**为什么不是B树而是B+树**？

1. B树不仅存键值，也存数据；B+树非叶子节点是不存数据的，仅存储键值，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
2. B+树索引的所有数据均存储在叶子节点，而且数据是按顺序排列的，通过双向链表相连，从而使得范围查找，排序查找，等等变得更加有效、快捷。

## 四、索引

**聚簇索引和非聚簇索引**

在InnoDB，索引B+树的叶子节点存储了整行数据的是主键索引，也被称为聚簇索引，即将数据存储和索引放在了一起，找到了索引就找到了数据。

而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。

聚簇索引和非聚簇索引的区别：

1. 非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键。
2. 对于InnoDB来说，想要查找数据还需要根据主键再去聚簇索引里进行查找，这个过程称为回表。
3. 通常情况，聚簇索引只会查一次，而非聚簇索引会查多次。
4. 聚簇索引中键值的逻辑顺序决定了表中相应行的物理顺序。
5. 非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

**非聚簇索引一定会回表查询吗？**

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

**联合索引是什么？为什么需要主要联合索引中的顺序？**

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

**Mysql的最左前缀原则？**

最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。

**前缀索引**

因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。

**怎么查看mysql语句中有没有用到索引？**

explain

**为什么官方建议使用自增长主键作为索引？？**

结合B+Tree的特点，自增主键是连续的，可以在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

**如何创建索引？**

1.  在执行CREATE TABLE时创建索引。
2. 使用ALTER TABLE命令去增加索引。
3. 使用CREATE INDEX命令创建。

**创建索引时需要注意什么？**

可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则。

**索引那些情况会失效**

* 查询条件包含or，可能导致索引失效
* 如何字段类型是字符串，where时一定用引号括起来，否则索引失效
* like通配符可能导致索引失效。
* 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。

**索引不适合哪些场景？**

* 数据量少的情况
* 更新比较频繁的也不适合加索引
* 区分度低的字段不适合加索引

**建索引的原则有哪些？**

1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
3. 尽量选择区分度高的列作为索引。
4. 索引列不能参与计算。
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

**索引的一些潜规则**

* 覆盖索引.
* 回表.
* 索引数据结构(b+树)
* 最左前缀原则.
* 索引下推.

**索引的种类**

1. 从存储结构上分为 btree索引、hash索引、full-index索引
2. 从应用层来分：普通、唯一、符合
3. 根据数据的物理存储与键值的逻辑(索引) 聚簇索引、非聚簇索引

## 五、MySQL主从复制

**为什么需要主从复制**

随着业务的增长，一台数据服务器已经满足不了需求了，负载过重。这个时候就需要减压了，实现负载均衡读写分离，一主一丛或一主多从。

主服务器只负责写，而从服务器只负责读，从而提高了效率减轻压力。

主从复制可以分为：

- 主从同步：当用户写数据主服务器必须和从服务器同步了才告诉用户写入成功，等待时间比较长。
- 主从异步：只要用户访问写数据主服务器，立即返回给用户。
- 主从半同步：当用户访问写数据主服务器写入并同步其中一个从服务器就返回给用户成功。

**形式**

一主一从、一主多从、多主一从、双主复制

**原理**

MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。

**工作过程**

MySQL 的主从复制工作过程大致如下：

1. 从库生成两个线程，一个 I/O 线程，一个 SQL 线程;
2. I/O 线程去请求主库的 binlog，并将得到的 binlog 日志写到 relay log(中继日志) 文件中;
3. 主库会生成一个 log dump 线程，用来给从库 I/O 线程传 binlog;
4. SQL 线程会读取 relay log 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致;

![img](https://dl-harmonyos.51cto.com/images/202204/5132b2c63a1331515f505679557dcf5971e8bc.png)



![MySQL 主从复制过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



## MySQL优化了解吗？说一下从哪些方面可以做到性能优化？

* 为搜索字段创建索引
* 避免使用select*,列出需要查询的字段
* 分表
* 选择正确的存储引擎

## 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？

单个数据库实例能够承载的并发访问量和数据量是有限的，当系统的并发访问量或者数据量超过这个限制时，就需要考虑使用分库分表来优化系统的架构设计，使其能够承载更大的并发量和数据量，并给用户提供良好的使用体验。当然，分库和分表其实是两个事情，两者并不是都会同时出现。

### 1. 分库解决了什么问题

分库主要解决的是**并发量大**的问题，因为单个数据库实例能够提供的连接数是有限的，当系统并发量不断增加，我们势必需要增加更多的微服务实例来承载更多的业务请求，而每个微服务实例都会占用一定量的数据库连接，因此，当数据库连接数不够用了，就只能通过增加数据库实例的方式来提供更多的数据库连接，进而提升系统整体的并发度。

### 2. 分表解决了什么问题

分表主要解决的是**数据量大**的问题，因为单表的数据量很大时，即使并发访问量不大，但单表的存储和查询的性能已经遭遇了瓶颈，通过索引优化等手段虽然能够一定程度上提升效率，但当单表数据量超过 500 万行或者单表存储容量超过 2GB（经验值，实际要看业务的具体情况） 之后，分表就应该提上日程了。一般都是将数据拆分到多张表中，来减少单表的数据量，从而提升查询的速度

## 主键索引和唯一索引的区别？

* 普通索引：无任何约束作用，就是用来提高查询效率
* 唯一索引：在普通索引的基础上，增加了唯一性约束，要求索引列的值比u唯一，但可以为空，一张表可以存在多个唯一索引。
* 主键索引： 在唯一索引的基础上又增加了不能为空的约束，而且一张表最多只能有一个主键索引，但一个主键索引可以包含多个字段。
* 全文索引





















